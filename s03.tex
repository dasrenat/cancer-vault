\subsection{Типы данных}
\subsubsection{Скаляры}

Печатать фразы на экране быстро надоедает. Гораздо полезней было бы 
начать производить какие-нибудь вычисления. Но вычисления производят над 
данными, а данные нужно где-то хранить. Для этого существуют переменные, а 
точнее \emph{скаляры} . В скаляре может храниться практически всё, что 
угодно, но только одно! Будь то числа, строки или, например, картинки. 
Универсальный контейнер на все случаи жизни. Неважно, какие данные вы 
хотите сохранить в скаляре, Perl всю рутину берёт на себя. В отличие, 
например, от Си, в котором целые и вещественные\footnote{Вещественные --- 
дробные числа} числа должны храниться в переменных разных типов.

Имя скаляра может содержать буквы латинского алфавита, цифры, символы 
подчёркивания. Причем идентификатор\footnote{Идентификатор --- имя скаляра, 
массива, хэша и т.п. Имя вашей переменной.} не должен начинаться с цифры. 
Вот примеры имён скаляров:

\begin{itemize}
\item \$counter
\item \$thread\_4574321
\item \$my\_var
\end{itemize}

Внимательный читатель должен был заметить знак доллара. Это 
\emph{разыменовывающий префикс} . Он говорит интерпретатору, что следующий 
за ним текст --- имя скаляра. Для каждого типа данных свой разыменовывающий 
префикс. \$ --- для скаляров. Легко запомнить, он похож на латинскую ’s’ в 
слове ’scalar’. @ --- для массивов, тоже легко запомнить, как лат. ’a’ в слове 
’array’. Ну и \% --- для хэшей. Символ процента должен напоминать о двойственной
природе данного типа --- ключ/значение, но об этом позже.

Важный момент! Perl регистрозависим. Это означает, что \$YOBA и \$Yoba это два 
разных скаляра, не забывай об этом! Тащемта скаляр --- это просто 
именованный кусочек памяти, в котором программа хранит свои данные.

Теперь мы знаем достаточно и можем использовать скаляры. Давай сохраним в скаляр
какое-нибудь значение:

\begin{verbatim}
$foo = 12345679;
\end{verbatim}

Что мы видим? Во-первых скаляр \$foo. Затем идёт оператор присваивания. Очень 
важно не путать оператор присваивания „=” с оператором равенства „==”. В 
данном случае, значок „=” говорит: „Скаляр \$foo устанавливается равным 
12345679”. 12345679 в нашем случае является константой. Константа зашивается в 
программу, ей нельзя присваивать значение, её нельзя изменить. Но это, мне 
кажется, и так понятно. В конце идёт старый добрый символ точки с запятой, 
завершающий операцию присваивания.

Давай поподробней остановимся на операциях. Операция есть какое-либо 
основное действие, предусмотренное самим языком. Операции бывают унарные 
(работают с одним значением), бинарные(два значения) и даже тернарные (три 
значения, разумеется, таких будет только одна). Операции отделяются друг 
от друга точкой с запятой. В нашем примере используется бинарная операция 
присваивания. В ней левому значению-операнду (наш скаляр \$foo) 
присваивается значение, находящееся справа (12345679). Также интересно знать, 
что Perl игнорирует пробельные символы (пробел, табуляция, перевод строки) 
везде, где только можно. Поэтому наше присваивание можно записать даже 
так:

\begin{verbatim}
        $foo
=
                12345679
;
\end{verbatim}

Давай теперь запустим такой скрипт:

\perl{l03.pl}

В выводе мы использовали ранее оговоренное явление интерполяции. Как 
видно по четвёртой строке, вместо имени скаляра (\$foo) в print подставляется 
его значение. Но что, если нам нужно вывести идентификатор скаляра, а не 
его значение? Для этого мы \remph{экранируем} (отключаем) бэкслэшем 
разыменовывающий префикс \remph{\$} .

Как я уже говорил, в скаляре можно хранить не только числа. К примеру:

\begin{verbatim}
$bar= "SERBIA STRONG!\n";
\end{verbatim}

Несложно догадаться и о том, какие арифметические операции есть в нашем 
распоряжении:

\begin{verbatim}
$baz= 99/2*3+4-5;
++$foo; #аналогично $foo= $foo +1 или $foo+= 1;
\end{verbatim}

Пояснения требует разве что последняя строчка. В ней с помощью унарной 
операции значение скаляра \emph{инкрементируется} (увеличивается на 
единицу). Существует также краткая запись для операции \emph{декремента} 
(уменьшения на единицу), как ни странно, она выглядит так „\texttt{-\--}”.

Инкремент и декремент не так просты как кажутся. Их можно записать в 
префиксной (до операнда\footnote{Операнд --- аргумент операции. Данные, которые 
обрабатываются командой}) и постфиксной форме (после операнда). Выбор той 
или иной формы записи есть дело вкуса, но только в том случае, если 
инкрементирование/декрементирование не входит в состав других операций. 
В случае префиксной формы ин(де)кремент выполняется до выполнения 
операции, при постфиксной форме --- после. Пример:

\perl{l04.pl}

Вики гласит: \remph{Скалярные переменные используются для хранения одиночных
значений. Они могут содержать числа, строки и ссылки на другие объекты.
Перед именем скалярной переменной необходимо ставить знак доллара ’\$’.
Тип скалярной переменной не фиксирован (в отличие от, например, языка 
Си) и определяется динамически в зависимости от контекста.}

Примеры:

\perl{l05.pl}

В первой строке мы видим присваивание, ничего необычного, вторая тоже не должна
удивить. В третьей строке мы видим новый оператор. Точкой в Perl'е обозначена
"конкатенация" или "склеивание строк". Буквально операция из 3й строки означает
следующее: "Возьми значение \$x, считай его строкой. Добавь в конец этой строки
строку 'string' и результат запиши в скаляр \$z.
Оставшиеся строки работают со ссылками. Ссылка это скаляр содержащий адрес
какого-либо объекта, сейчас мы не будем их рассматривать, ссылкам посвящен отдельный
раздел.

{\large{\textbf{Вопросы для самоконтроля:}}}

\begin{enumerate}
\item Что такое операция, операнд и оператор?
\item Для чего предназначены скаляры?
\item Что такое разыменовывающий префикс и идентификатор скаляра?
\item Чем отличается префиксная и постфиксная форма записи в унарных
операциях?
\end{enumerate}

{\large{\textbf{Задания к разделу:}}}

\begin{enumerate}
\item Приведи пример унарных и бинарных операций.
\item Найди в сети информацию о требованиях, предъявляемых к
идентификаторам. Какие стили именования переменных существуют? Что такое
\remph{верблюжья нотация} ?
\item Что будет напечатано на экране после выполнения скрипта? В чём
ошибка?

\perl{l06.pl}

Так уж и быть, дам развёрнутый ответ на первый вопрос. Тем более, что он не 
вполне очевиден. Как видно, скаляр начинает существовать с момента его 
первого упоминания, что очень плохо и в будущем мы научимся лечить этот 
недуг с помощью прагмы strict. Если такому скаляру не присвоить какое-либо 
значение, его содержимое будет не определено. Числовой эквивалент 
неопределенного значения равен нулю. Поэтому результатом выражения 
является ноль. Ответ на второй вопрос найти не трудно, но я подскажу. Perl 
регистрозависим!
\item Напиши 4 способа увеличить значение скаляра на 1 одной
операцией. Не выходит? Двадцать отжиманий.
\item Обладая знаниями об однострочниках, скалярах и операциях, уже
сейчас можно использовать Perl, как калькулятор. Напиши однострочник,
приводящий обыкновенную дробь $\frac{355}{113}$ за авторством китайского
астронома Цзу Чунчжи, в десятичный вид. Часть какого числа скрывается в
данной дроби?

\item Поиграйся с операцией конкатенации, чтобы понять как она работает.
\item Попробуй догататься, как можно короче записать операцию?
\begin{verbatim}
$x = $x . ' some text';
\end{verbatim}

\item Какое число будет напечатано в результате этой операции?
  Почему так произошло?
\begin{verbatim}
perl -E '$i = 667; say $i--'
\end{verbatim}
\end{enumerate}
