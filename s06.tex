\subsubsection{Хэши}

Хэши --- неупорядоченные наборы скалярных значений доступ к которым осуществляется не по индексу, как в случае с массивами, а по ключу. Разыменовывающим префиксом для хэшей является знак процента. Выбор на этот символ пал потому, что он позволяет заявить о двойственной природе хэшей (два кружка разделённых чертой).

Инициализируются хэши с помощью списков, количество элементов в котором должно быть чётным:
\begin{verbatim}
my %hash = ('key1', 'value1', key2', 'value2',
  key3', 'value3');

print $hash{key1};
\end{verbatim}

Как видно, в отличии от массивов, доступ к элементу хэша осуществляется с помощью фигурных скобок. Ключ можно записывать без кавычек.

Порядок следования пар в инициализирующем списке значения не имеет:

\begin{verbatim}
my $key = 'key2';
my %hash = ($key => 'value2', key1 => 'value1',
  key3 => 'value3');

print $hash{key1};
\end{verbatim}

Обрати внимание на новый оператор \texttt{``=>''}, который называется ``fat comma'' или жирная запятая. Этот оператор часто используется при инициализации хэшей т.к. во-первых улучшает читабельность кода, во-вторых он автоматически заключает свой левый аргумент в двойные кавычки. В остальном он абсолютно аналогичен обычной запятой.

Давай попробуем посмотреть, как устроены хэши чтобы лучше понять, что же они из себя представляют и чем отличаются от массивов.

Каждый хэш состоит из некоторого количества ``корзин''. Корзины представляют из себя анонимные массивы. Минимальное число корзин равно восьми. Если количество записей становится равным числу корзин --- количество корзин удваивается.

Сердцем хэша является т.н. ``хэш-функция'', отсюда и название структуры данных.

Как же происходит запись в хэш?

\begin{enumerate}
\item Хэшу передаётся пара ключ/значение.
\item Хэш функция вычисляет контрольную сумму от ключа, допустим она равна семи.
\item Пара ключ/значение записывается в седьмую корзину. 
\end{enumerate}

Как мы получаем данные из хэша?

\begin{enumerate}
\item Хэшу передаётся ключ.
\item Хэш функция вычисляет контрольную сумму от ключа, допустим она равна семи.
\item В массиве представляющем собой седьмую корзину ищется пара с переданным ключём,
  если пара найдена --- возвращается соответствующее значение, иначе --- возвращается undef.
\end{enumerate}

То в какую именно корзину попадёт значение будет зависеть как от числа корзин так и от 
реализации хэш-функции. Теперь понятно почему пары в хэшах не упорядочены?

А теперь попробуй 5-6 раз запустить данный однострочник:
\begin{verbatim}
perl -E '%h = qw( key1 val1 key2 val2 key3 val3); $,=" "; say %h'
\end{verbatim}

Как видно, в списочном контексте хэш возвращает пары ключ-значение, но порядок пар меняется
от запуска к запуску, если интересно почему так происходит --- читай следующий абзац, иначе
можешь просто пропустить его.

В идеальном случае в каждой корзине храниться одно значение. К сожалению иногда могут происходить коллизии --- случаи когда 2 и более элемента попадают в одну корзину. В таких
ситуациях время поиска значения возрастает. Злоумышленник может намеренно
спровоцировать такое вот вырождение хэша. Чтобы избежать этого, в хэш-функции присутствует
случайное зерно, которое меняется от пуска к пуску.

% overhead хэшей, в т.ч. из-за удваивания числа корзин
% память vs cpu
% пример для массивов - точки в 3d модели
