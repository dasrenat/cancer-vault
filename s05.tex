\subsubsection{Массивы}

Ранее мы говорили о скалярах, причем говорили уважительно. Каждый скаляр 
у нас был индивидуален, со своим уникальным идентификатором. Но такой 
подход не всегда возможен. Представь, что мы хотим обработать книгу и 
каждую её строчку хорошо бы поместить в отдельный скаляр. Сотни, тысячи 
скаляров! Каждому нужно придумать имя --- нет пути! Поэтому существуют 
массивы. Я уже говорил, что у массивов рызыменовывающим префиксом служит 
собака? Массив похож на цугундер, где скаляры сидят в камерах под 
порядковыми номерами, а собака их охраняет.

Ну что ж, давай попробуем наполнить нашу тюрьму арестантами и сделать 
что-нибудь с одним из них:

\label{prisoners-src}\perl{l07.pl}

В строках 3 и 4 мы задаём список начальных значений для массива. Иначе 
можно сказать, мы ``инициализируем'' массив. Строка не помещалась на 
странице и я разбил её на две, я уже говорил, что перлу плевать на подобные 
отступы. К имени каждого арестанта был добавлен символ перевода строки, 
иначе имена склеились бы во время вывода (строка 10). Попробуй убрать 
переводы строк и посмотри, что из этого получится. После присваивания 
массиву списка арестантов, мы можем обращаться к каждому из них по 
индексу. Нумерация начинается с нуля, очень важно не забывать об этом! Т.е. 
после присваивания в нулевой камере находится Юрий Есин, а индекс Ильхама 
равен трём. Но, по-видимому, 0 вызывает у Юрия неприятные ассоциации, 
поэтому администрация решила пойти на уступки, поменяв его местами с 
Ильхамом. Этот процесс простирается с 6й по 8ю строку. В шестой строке мы 
копируем Ильхама в скаляр с именем \$temp. В седьмой Юрий Есин 
переезжает из нулевой камеры в третью, тем самым стирая с лица земли 
клон Ильхама, теперь у нас два Юрия! Но это ненадолго, в восьмой строке 
Ильхам занимает положенное место. Заметь, что когда речь идёт о 
конкретном значении массива, рызыменовывающий префикс меняется на знак 
доллара. Так мы говорим Perl`у, что подразумеваем конкретный скаляр 
(конкретного зека), а не весь массив. Вот так например можно вывести
содержимое элемента с индексом два:

\begin{verbatim}
print $jail[2];
\end{verbatim}

Также существуют отрицательные индексы. Индекс -1 позволяет получить 
доступ к последнему элементу, -2 к предпоследнему и так далее. Всегда можно 
узнать размер массива:

\begin{verbatim}
print $#jail +1 . "\n";
\end{verbatim}

Кстати, точка осуществляет конкатенацию (склеивание) строк. В переменной 
\$\#имя\_массива содержится индекс последнего элемента массива. Если 
прибавить к значению этой переменной единицу, мы получим количество 
элементов в массиве.

Для работы с массивами существует ряд подпрограмм (функций):

\begin{itemize}
\item push @array значение; \# Добавить значение в конец массива.
\item pop @array;           \# Удаляет последний элемент и возвращает его значение.
\item unshift @array;       \# добавляет элемент в начало массива.
\item shift @array;         \#удаляет первый элемент и возвращает его значение.
\end{itemize}

Что значит \remph{возвращает} ? Любой оператор, любая подпрограмма в
Perl что-то возвращает. Возвращаемое значение можно использовать или
игнорировать, но оно есть:

\perl{l08.pl}

В данном примере интерпретатор встречает имя подпрограммы \remph{pop}. Она 
удаляет последний элемент массива (Ильхам Зюлькорнеев) и возвращает его 
значение. Т.е. подставляет на место своего вызова. После того, как pop 
сделает своё дело, она как бы подставит в строку 6 вместо \remph{pop(@jail)} 
удалённый ранее элемент. Мы могли никак не отреагировать на возвращаемое 
значение, но в данном случае оно пригодилось. В строке 8 выводится 
значение последнего элемента, теперь можно видеть, что крайний у нас 
Владимир Дерюжкин.

Кстати! Если элемент не должен содержать пробелов, можно воспользоваться 
специальной конструкцией \remph{qw()},\footnote{От англ. quote word} которая аналогична двойным кавычкам, 
при этом, она сама расставляет запятые и кавычки, что экономит время.

Пример:

\begin{verbatim}
@a= qw(Один Два Три 4 5 6 7);
# существенно короче чем @a = ('Один', 'Два', ... )
\end{verbatim}

\subsubsection*{Контекст}

Некоторые вещи написанные на Perl'е могут иметь различное значение в зависимости от контекста. Влияние
контекста продемонстрируем с помощью однострочника:

\begin{verbatim}
perl -E '@a=qw(a b c); say @a; say $foo= @a'
\end{verbatim}

Эта бесполезная программа добавляет в наш арсенал сразу несколько новых трюков.

Аргумент интерпретатора``-E''  аналогичен ключу ``-e'', с той лишь разницей, что перед выполнением кода
он подключает некоторые опциональные вещи, одной из которых является функция ``say''. ``say'' работает
так же как и ``print'', но при этом она автоматически добавляет перевод строки к списку своих аргументов.
Perl также позволяет забить на точку с запятой, если выражение стоит в конце блока. Что такое ``блок'' мы
узнаем позднее.

Вернёмся к нашему однострочнику. Первый вызов ``say'' напечатает содержимое массива ``@a'', второй ---
его размер, но почему так происходит? Дело в контексте, который бывает скалярным и списочным.
Что такое скаляр мы уже усвоили, про списки же говорим впервые, хотя ранее использовали их.
В части ``@a=qw(a b c);'' нашего примера, массив ``@a'' инициализируется списком из трёх
элементов\footnote{Последующие несколько абзацев, является вольным пересказом поста из блога Майка Фридмана 'Arrays vs. Lists in Perl'. Прямую ссылку не привожу во-первых потому, что уже сейчас она не работает,
читаю из кэша гугла, во-вторых --- всё в два счёта гуглится.}. Чем же массив отличается от списка?\newline
\subsubsection*{Массивы --- переменные, списки --- нет.}
Со списком нельзя работать так, как мы работаем с переменными. Списки эфемерны и не существуют за пределами
мест в которых используются.

\subsubsection*{Содержимое массивов может быть изменено.}
Если заголовок подраздела тебя удивил --- перечитай главу про массивы с начала. Пример:
\begin{verbatim}
push @array, 4, 5, 6, 7, 8;
print $a[-1]*= 6;
\end{verbatim}

Списки --- неизменны, попробуй запустить следующий однострочник:
\begin{verbatim}
perl -e 'push ( 3, 4, 5 ), (6, 7)'
\end{verbatim}

\subsubsection*{Массивы могут использоваться в скалярном контексте, списки --- нет.}
Выше я приводил пример использования массивов в скалярном контексте, настало время списков:
\begin{verbatim}
perl -E 'say $foo = (900, 901, 42)'
\end{verbatim}
Данный однострочник напечатает ``42'', но это не значит что список в скаляром контексте возвращает свой
последний элемент. В скалярном контексте списков не бывает и правая часть присваивания интерпретируется
как обычное выражение с оператором ``запятая''. Данный оператор возвращает правостоящий операнд. Т.е.
первая запятая вернёт ``901, 42'', а вторая
просто ``42''.

Массив в скаояперм креиексие возвращает количество элементов в нём содержащееся, это важная идиома, запомни
её:

\begin{verbatim}
perl -E 'say $foo = @a = (900, 901, 42)'
\end{verbatim}

Существуют и другие отличия, но мы пока не изучили вещей, которые позволят их осознать, поэтому вернёмся к ним когда будем говорить о ссылках и подпрограммах.

\subsubsection{Срезы массивов и списков}

Зачастую нас интересует только какая-то часть массива/списка, например:

\perl{l09.pl}

localtime\footnote{Подробней про localtime можно прочитать в соотв. разделе документации: ``perldoc -f localtime''} принимает в качестве параметра значение эпохи, которое равно количеству секунд прошедших
с 1 января 1970 года. Получить это значение можно с помощью функции time.


localtime возвращает список из 9 элементов, допустим нас интересуют только элементы с индексами 6 и 7,
под которыми хранятся порядковый номер текущего дня в году (0..364, 365 для високосных) и номер дня недели (0 - воскресенье)
соответственно.


А что если нужно узнать какое число будет через неделю?

\perl{l10.pl}

Число месяца можно найти по индексу 3.


С помощью срезов можно делать и более интересные вещи:

\perl{l11.pl}

В данном листинге мы освоим сразу несколько новых трюков. Во-первых, обрати внимание на спец. переменную
``\texttt{\$"}''\footnote{О других специальных переменных можно прочитать в ``perldoc perlvar''}. В ней хранится
последовательность которой будут разделены элементы массива во время интерполяции, например в двойных
кавычках. По умолчанию этой последовательностью является пробел, я заменил её на запятую с пробелом.
Во-вторых, обрати внимание, как хитро я решил проблему с переводом строки. Это тот самый TIMTOWTDI за
который перлокодеры так любят Perl. В-третьих, я получил два среза.  Первый получает диапазон из трёх
элементов, второй последний элемент массива. Обрати внимание на разыменующий префикс массива. Собака
говорит о том, что мы собираемся получить не элемент массива, а его срез и результатом этой операции
будет список. Поэтому, для обращения к элементу массива, мы пишем знак доллара. Следующий листинг призван
пролить свет на вышеизложенное:

\perl{l12.pl}

Как видно, при присваивании констант всё нормально и предсказуемо но результат работы localtime зависит
от контекста. В 14 строке контекст скалярный и элемент массива получит текстовое значение даты, в 15 же 
контекст списочный и в 2й элемент массива @dates будет записан первый элемент списка возвращённого
localtime.

Мы узнали много полезных фитч и можем переписать листинг со страницы \pageref{prisoners-src} более 
кратко и элегантно:

\perl{l13.pl}

В третьей строке мы просим интерпретатор подключить фитчи доступные в версии ``5.010'', после чего нам
становятся доступны функция ``say'' и специальная переменная ``\texttt{\$,}'', с помощью которой можно задать
разделитель, который будет использоваться ``say'' для конкатенации списка своих аргументов. В строке 10 мы с
помощью срезов меняем местами первый и последний, или как сказал бы военный ``крайний'', элементы массива.

{\large{\textbf{Вопросы для самоконтроля:}}}

\begin{enumerate}

  \item В чём отличие между ``\texttt{@array[\$i]}'' и ``\texttt{\$array[\$i]}''?
  \item Какие значения получат скаляры?
\begin{verbatim}
my @array = qw( 4 5 6 qux );

$foo = @array;
$bar = $#array;
\end{verbatim}

\end{enumerate}

{\large{\textbf{Задания к разделу:}}}
\begin{enumerate}

\item Попробуй догадаться что напечатает однострочник, затем запусти его и объясни как он работает:

\begin{verbatim}
perl -E 'say qw qa e f l n o r vq[2,5..90,1,-1,0,-2,0,3,5,4,1]'
\end{verbatim}

Как бонус для тех кто добросовестно выполняет задания, я расскажу как можно облегчить себе жизнь в 
подобных ситуациях:

\begin{verbatim}
perl -MO=Deparse -E '
  say qw qa e f l n o r vq[2,5..90,1,-1,0,-2,0,3,5,4,1]'
\end{verbatim}

``\texttt{B::Deparse}'' --- модуль который генерирует исходный код. Он удаляет всякий синтаксический сахар, 
ненужные интерпретатору вещи вроде комментариев и пробельных символов.

Другими словами, с помощью ``\texttt{B::Deparse}'', мы можем увидеть исходный код нашего скрипта, таким,
каким его видит интерпретатор.

Я подключил модуль к программе с помощью ключа ``\texttt{-MO=Deparse}'', а ещё мне пришлось разбить
исходник на две строки, чтоб он поместился на страницу. 

Если запустить скрипт с командой ``\texttt{perl -w -E}'' --- можно увидеть, что в нём допущена помарка,
найди и исправь её.

\item Напиши однострочник, который с помощью среза удаляет первые три элемента массива. Решение должно
работать для массивов любой длины большей 2.

\end{enumerate}
