\subsubsection{Массивы}

Ранее мы говорили о скалярах, причем говорили уважительно. Каждый скаляр 
у нас был индивидуален, со своим уникальным идентификатором. Но такой 
подход не всегда оправдан. Представь, что мы хотим обработать книгу и 
каждую её строчку хорошо бы поместить в отдельный скаляр. Сотни, тысячи 
скаляров! И каждому нужно придумать имя --- нет пути! Поэтому существуют 
массивы. Я уже говорил, что у массивов рызыменовывающим префиксом служит 
собака? Массив похож на тюрьму, где скаляры сидят в камерах под 
порядковыми номерами, а собака их охраняет.

Ну что ж, давай попробуем наполнить нашу тюрьму арестантами и сделать 
что-нибудь с одним из них:

\perl{l07.pl}

В строках 3 и 4 мы задаём список начальных значений для массива. Иначе 
можно сказать, мы „инициализируем” массив. Строка не помещалась на 
странице и я разбил её на две, я уже говорил, что перлу плевать на подобные 
отступы. К имени каждого арестанта был добавлен символ перевода строки, 
иначе имена склеились бы во время вывода (строка 8). Попробуй убрать 
переводы строк и посмотри, что из этого получится. После присваивания 
массиву списка арестантов, мы можем обращаться к каждому из них по 
индексу. Нумерация начинается с нуля, очень важно не забывать об этом! Т.е. 
после присваивания в нулевой камере находится Юрий Есин, а индекс Ильхама 
равен трём. Но, по-видимому, 0 вызывает у Юрия неприятные ассоциации, 
поэтому администрация решила пойти на уступки, поменяв его местами с 
Ильхамом. Этот процесс простирается с 5й по 7ю строку. В пятой строке мы 
копируем Ильхама в скаляр с именем \$temp. В шестой строке Юрий Есин 
переезжает из нулевой камеры в третью, тем временем стирая с лица земли 
клон Ильхама, теперь у нас два Юрия! Но это ненадолго, в седьмой строке 
Ильхам занимает положенное место. Заметьте, что когда речь идёт о 
конкретном значении массива, рызыменовывающий префикс меняется на знак 
доллара. Так мы говорим Perl`у, что подразумеваем конкретный скаляр 
(конкретного зека), а не весь массив. Вот так например можно вывести
содержимое элемента с индексом два:

\begin{verbatim}
print $jail[2];
\end{verbatim}

Также существуют отрицательные индексы. Индекс -1 позволяет получить 
доступ к последнему элементу, -2 к предпоследнему и так далее. Всегда можно 
узнать размер массива:

\begin{verbatim}
print $#jail +1 . "\n";
\end{verbatim}

Кстати, точка осуществляет конкатенацию (склеивание) строк. В переменной 
\$\#имя\_массива содержится индекс последнего элемента массива. Если 
прибавить к значению этой переменной единицу, мы получим количество 
элементов в массиве.

Для работы с массивами существует ряд подпрограмм (функций):

\begin{itemize}
\item push @array значение ; \#Добавить значение в конец массива.
\item pop @array; \#Удаляет последний элемент и возвращает его значение.
\item unshift @array; \#добавляет элемент в начало массива.
\item shift @array; \#удаляет первый элемент и возвращает его значение.
\end{itemize}

Что значит \remph{возвращает} ? Любой оператор, любая подпрограмма в
Perl что-то возвращает. Возвращаемое значение можно использовать или
игнорировать, но оно есть:

\perl{l08.pl}

В данном примере интерпретатор встречает имя подпрограммы \remph{pop}. Она 
удаляет последний элемент массива (Ильхам Зюлькорнеев) и возвращает его 
значение. Т.е. подставляет на место своего вызова. После того, как pop 
сделает своё дело, она как бы подставит в строку 5 вместо \remph{pop(@jail)} 
удалённый ранее элемент. Мы могли никак не отреагировать на возвращаемое 
значение, но в данном случае оно пригодилось. В строке 6 выводится 
значение последнего элемента, теперь можно видеть, что крайний у нас 
Владимир Дерюжкин.

Кстати! Если элемент не должен содержать пробелов, можно воспользоваться 
специальной конструкцией \remph{qw()},\footnote{От англ. quote word} которая аналогична двойным кавычкам, 
при этом, она сама расставляет запятые и кавычки, что экономит время.

Пример:

\begin{verbatim}
@a= qw(Один Два Три 4 5 6 7);
# существенно короче чем @a = ('Один', 'Два', ... )
\end{verbatim}

\subsubsection*{Контекст}

Некоторые вещи написанные на Perl'е могут иметь различное значение в зависимости от контекста. Влияние
контекста продемонстрируем с помощью однострочника:
\begin{verbatim}
perl -E '@a=qw(a b c); say @a; say $foo= @a'
\end{verbatim}
Эта бесполезная программа добавляет в наш арсенал сразу несколько новых трюков.

Аргумент интерпретатора``-E''  аналогичен ключу ``-e'', с той лишь разницей, что перед выполнением кода
он подключает некоторые опциональные вещи, одной из которых является функция ``say''. ``say'' работает
так же как и ``print'', но при этом она автоматически добавляет перевод строки к списку своих аргументов.
Perl также позволяет забить на точку с запятой, если выражение стоит в конце блока. Что такое ``блок'' мы
узнаем позднее.

Вернёмся к нашему однострочнику. Первый вызов ``say'' напечатает содержимое массива ``@a'', второй ---
его размер, но почему так происходит? Дело в контексте, который бывает скалярным и списочным.
Что такое скаляр мы уже усвоили, про списки же говорим впервые, хотя ранее использовали их.
В части ``@a=qw(a b c);'' нашего примера, массив ``@a'' инициализируется списком из трёх
элементов\footnote{Последующие несколько абзацев, является вольным пересказом поста из блога Майка Фридмана 'Arrays vs. Lists in Perl'. Прямую ссылку не привожу во-первых потому, что уже сейчас она не работает,
читаю из кэша гугла, во-вторых --- всё в два счёта гуглится.}. Чем же массив отличается от списка?\newline
\subsubsection*{Массивы --- переменные, списки --- нет.}
Со списком нельзя работать так, как мы работаем с переменными. Списки эфемерны и не существуют за пределами
мест в которых используются.

\subsubsection*{Содержимое массивов может быть изменено.}
Если заголовок подраздела тебя удивил --- перечитай главу про массивы с начала. Пример:
\begin{verbatim}
push @array, 4, 5, 6, 7, 8;
print $a[-1]*= 6;
\end{verbatim}

Списки --- неизменны, попробуй запустить следующий однострочник:
\begin{verbatim}
perl -e 'push ( 3, 4, 5 ), (6, 7)'
\end{verbatim}

\subsubsection*{Массивы могут использоваться в скалярном контексте, списки --- нет.}
Выше я приводил пример использования массивов в скалярном контексте, настало время списков:
\begin{verbatim}
perl -E 'say $foo = (900, 901, 42)'
\end{verbatim}
Данный однострочник напечатает ``42'', но это не значит что список в скаляром контексте возвращает свой
последний элемент. В скалярном контексте списков не бывает и правая часть присваивания интерпретируется
как обычное выражение с оператором ``запятая''.
Данный оператор возвращает правостоящий операнд. Т.е. первая запятая вернёт ``901, 42'', а вторая
просто ``42''.

Существуют и другие отличия, но мы пока не изучили вещей, которые позволят их осознать, поэтому вернёмся к ним когда будем говорить о ссылках и подпрограммах.

\subsubsection{Срезы массивов.}
\begin{verbatim}
 perl -E 'say qw qa e f l n o r vq[2,5..6,1,-1,0,-2,0,3,5,4,1]'
\end{verbatim}
